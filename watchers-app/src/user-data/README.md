# User data

The database uses MongoDB interfacing via [Prisma](https://www.prisma.io/), an ORM interface which generates code to interact with databases programatically. This greatly simplifies coding of database operations, and allows a relational model to be defined even though MongoDB is a NoSQL database. Hence, the benefits of MongoDB performance can be used alongside the benefits of a relational model and its ease of usage with regards to programming paradigms. MongoDB is also beneficial in that it is performant at scale.

## Usage

### Prequisites

In the repository root directory (the git directory containing the entire project), make sure your repo is up to date with `git fetch`, then `git status` to check.

If your git is up to date then run `npm install` in the repository root directory.

Make sure you have installed MongoDB, you can follow the directions [here](https://www.mongodb.com/docs/manual/administration/install-community/).

### Setup (this only needs to be done once per machine/server)

#### Setup MongoDB

In your terminal, run the command `mongod` (this is the MongoDB background process). Alternatively, if you installed via Homebrew (on macOS) run `brew services start mongodb-community`.

#### Setup the .env file

Create a file in the `watchers-app/` directory, named `.env`.

Run `mongosh` in the terminal and note the URL it provides, which should begin with `mongodb://`.

Within it, add the following text:

```env
DATABASE_URL="<mongodb url here>"
```

Where `<mongodb url here>` is replaced by the MongoDB URL you just copied.

#### Initialize Prisma

Run `npx prisma db push` to generate the client and database automatically in MongoDB.

## User profile data concept

MongoDB is chosen as a NoSQL database. Using the JSON model of data access, it is easy to program with and use while remaining performant at scale.

The user data contains the following components:

- user unique ID
- username
- email
- password hash
- display name

The user posts data are in another collection differentiated using the unique ID

- post type (profile-post)
  - user unique ID
  - post unique ID
  - post text content
  - referenced movie unique ID
  - post likes:
    - user account likes (unique ID list)
  - post comments (only relevant if profile-post):
    - each comment body contains
      - commenting user unique ID
      - comment unique ID
      - comment text content
      - comment likes:
      - user account likes (unique ID list)

## Valid new user creation requirements

A new user MUST have a unique email, username, and unique ID. The email and username are chosen upon registration, and if either is present already in the database, the registration is prevented and an error is returned. The user may retry with a different email or username. Unique ID meanwhile, is an internal value generated by the database, so with each new user is guaranteed to be unique.

## User authentication

We use a password which is stored in a hashed format generated by [bcrypt](https://www.npmjs.com/package/bcrypt), as [storing passwords in plaintext is known to be insecure](https://security.stackexchange.com/questions/36833/why-should-i-hash-passwords). 

## User/Posts/Comments ID

Unique IDs results from [ObjectID](https://www.mongodb.com/docs/manual/reference/method/ObjectId/) in MongoDB which are provided by default.

## TODO/future goals

- The unique IDs could be created in a manner similar to the [Snowflake ID](https://en.wikipedia.org/wiki/Snowflake_ID) used by Twitter.
  - The snowflake ID is used to dynamically generate the user registration time deterministically yet in a manner that scales. This is also used for posts and comments.
- add media embeds to posts
- implement generation of unique IDs
- expand beyond movies
- consider performance of comment loading mechanism
- do we want to store comments separately? (separate comments and posts e.g. Instagram/Facebook etc) or display comments are also posts i.e. blur boundary between comments and posts (e.g. Twitter)
- consider security of login/hash or use Auth0 or another authentication service
- implement a security requirement to assess passwords for strength based on properties of common words and presence of non-alphabetic characters, etc
<!-- - Use MongoDB or another NoSQL database for scalability -->
